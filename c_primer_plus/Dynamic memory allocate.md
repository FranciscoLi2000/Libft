---
AIGC:
    ContentProducer: Minimax Agent AI
    ContentPropagator: Minimax Agent AI
    Label: AIGC
    ProduceID: "00000000000000000000000000000000"
    PropagateID: "00000000000000000000000000000000"
    ReservedCode1: 304502201cc9fc4e80148cf16653397344d275d684577f6e0a5811ce4b13a86fde35c654022100b3c7b1db60c6350a2fe75f86ebdd0918303f9e4199d99b5ef7db5c3cdbb9cdf0
    ReservedCode2: 304502200a2aec3884ad07d767ca2e8d442296c2044a18fcfb08e8920061d7320c949a24022100d7a8d69631998c0462c231dd13fdb92437845981b9159b9490a01ca405d11788
---

# 第12章：存储类别、链接和内存管理 - 动态内存分配核心内容

## 动态内存分配概述

- **静态存储**：在编译时确定大小，程序运行期间始终存在
- **自动存储**：进入块时分配，离开块时自动释放
- **动态存储**：运行时手动申请，手动释放，使用堆（heap）

## 动态内存分配函数

### 1. `malloc()` 函数

| 细节 | 说明 |
|------|------|
| **原型** | `void *malloc(size_t size);`（ANSI C 起返回 `void *`） |
| **作用** | 向堆申请 `size` 字节的连续内存块，返回首字节地址 |
| **返回值** | 成功 → 指向已分配内存块的指针；失败 → `NULL`（空指针） |
| **使用建议** | - 使用 `sizeof(type)` 计算所需字节数，提高可移植性<br>- **必须** 检查返回值是否为 `NULL`，并给出错误处理 |
| **示例** | ```c<br>double *ptd = (double *)malloc(max * sizeof(double));<br>if (ptd == NULL) {<br>    puts("Memory allocation failed. Goodbye.");<br>    exit(EXIT_FAILURE);<br>}<br>``` |

### 2. `free()` 函数

| 细节 | 说明 |
|------|------|
| **原型** | `void free(void *ptr);` |
| **作用** | 释放由 `malloc()`/`calloc()`/`realloc()` 分配的内存块，使其可再次被后续 `malloc()` 申请 |
| **使用原则** | - 只能释放 **已分配的** 内存<br>- 同一块内存 **不能** 多次 `free()`<br>- 建议在 **不再需要** 时立即 `free()`，防止内存泄漏 |
| **示例** | ```c<br>free(ptd);   // 释放之前 malloc 的内存<br>ptd = NULL;   // 防止悬空指针<br>``` |

### 3. `calloc()` 函数

| 细节 | 说明 |
|------|------|
| **原型** | `void *calloc(size_t nmemb, size_t size);` |
| **作用** | 分配 `nmemb` 个大小为 `size` 字节的存储单元，并 **全部清零** |
| **返回值** | 成功 → 指向已分配内存块的指针；失败 → `NULL` |
| **使用示例** | ```c<br>long *newmem = (long *)calloc(100, sizeof(long));<br>``` |
| **释放** | 同 `malloc`，使用 `free(newmem);` |

- **适用场景**：需要 **零初始化** 的数组、结构体等
- **优势**：不必手动 `memset` 即可得到全 0 内存

## 动态内存分配与变长数组（VLA）的对比

| 特性 | `malloc()`/`calloc()` | 变长数组（VLA） |
|------|------------------------|-----------------|
| **声明时机** | 运行时（`malloc`/`calloc`） | 运行时（`int ar[n];`） |
| **内存生命周期** | 手动 `free` 释放，可跨函数返回指针 | 自动在块结束/函数返回时销毁 |
| **返回** | 返回 `void *`，可赋值给任意指针类型 | 数组名是局部数组，**不能** 返回其地址 |
| **多维数组** | 语法繁琐（需手动计算行指针） | 直接声明 `int ar[n][m];`（编译器支持 C99） |

> **注意**：在 **C90** 标准中不支持 VLA，若需兼容旧编译器，只能使用 `malloc`/`calloc` 方式创建多维数组。

## 动态内存分配最佳实践

1. **始终检查返回值**：`malloc`/`calloc`/`realloc` 可能返回 `NULL`，务必在错误处理后继续
2. **配对使用**：`malloc` ↔ `free`；`calloc` ↔ `free`；`realloc` ↔ `free`（如果 `realloc` 失败则旧块仍然有效）
3. **使用 `sizeof(type)`**：避免硬编码字节数，提高可移植性
4. **及时释放**：在函数返回前、程序结束前 `free` 分配的内存，防止 **内存泄漏**
5. **防止悬空指针**：`free` 后将指针设为 `NULL`，避免后续误用
6. **何时使用 `calloc`**：当需要 **零初始化** 的内存时，`calloc` 能一次性完成，省去 `memset`
7. **了解 VLA 与 `malloc` 的区别**：
   - VLA 为自动存储，生命周期受块限制，适合 **局部、一次性** 的数组
   - `malloc` 分配的内存可 **跨函数、跨块** 使用，适合需要 **持久或返回** 的数据结构

## 内存区域划分

程序把可用内存划分为三部分：

1. **静态存储区**：外部、内部链接、无链接的静态变量——大小在编译时确定，程序全程存在
2. **自动存储区**：栈——块进入时分配，离开时释放
3. **动态存储区**：堆——`malloc`/`calloc`/`realloc` 分配，`free` 归还

## 生命周期对比

| 存储类别 | 分配时刻 | 销毁时刻 |
|----------|----------|----------|
| 静态 | 程序启动 | 程序结束 |
| 自动 | 进入块（函数、复合语句） | 离开块 |
| 动态 | 调用 `malloc`/`calloc`/`realloc` | 调用 `free` 或程序结束（系统可能自动回收） |